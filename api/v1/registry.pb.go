// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/v1/registry.proto

package v1

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	core "github.com/solo-io/solo-kit/pkg/api/v1/resources/core"
	math "math"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ApplicationType int32

const (
	ApplicationType_EXTENSION ApplicationType = 0
	ApplicationType_DEMO      ApplicationType = 1
	ApplicationType_MESH      ApplicationType = 2
)

var ApplicationType_name = map[int32]string{
	0: "EXTENSION",
	1: "DEMO",
	2: "MESH",
}

var ApplicationType_value = map[string]int32{
	"EXTENSION": 0,
	"DEMO":      1,
	"MESH":      2,
}

func (x ApplicationType) String() string {
	return proto.EnumName(ApplicationType_name, int32(x))
}

func (ApplicationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{0}
}

type MeshType int32

const (
	MeshType_ISTIO        MeshType = 0
	MeshType_LINKERD      MeshType = 1
	MeshType_AWS_APP_MESH MeshType = 2
)

var MeshType_name = map[int32]string{
	0: "ISTIO",
	1: "LINKERD",
	2: "AWS_APP_MESH",
}

var MeshType_value = map[string]int32{
	"ISTIO":        0,
	"LINKERD":      1,
	"AWS_APP_MESH": 2,
}

func (x MeshType) String() string {
	return proto.EnumName(MeshType_name, int32(x))
}

func (MeshType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{1}
}

// This is static content for an application. It includes basic metadata that is common to every version of an
// application, and a list of versions. For each version, there is information about how to install the application
// (for example, a Helm chart location), and the requirements for installation.
type ApplicationSpec struct {
	Type             ApplicationType `protobuf:"varint,1,opt,name=type,proto3,enum=hub.solo.io.ApplicationType" json:"type,omitempty"`
	Name             string          `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	LogoUrl          string          `protobuf:"bytes,3,opt,name=logo_url,json=logoUrl,proto3" json:"logo_url,omitempty"`
	ShortDescription string          `protobuf:"bytes,4,opt,name=short_description,json=shortDescription,proto3" json:"short_description,omitempty"`
	// Note that long description will be overwritten by the content of description.md if provided.
	LongDescription       string                      `protobuf:"bytes,5,opt,name=long_description,json=longDescription,proto3" json:"long_description,omitempty"`
	DocumentationUrl      string                      `protobuf:"bytes,6,opt,name=documentation_url,json=documentationUrl,proto3" json:"documentation_url,omitempty"`
	RepositoryUrl         string                      `protobuf:"bytes,7,opt,name=repository_url,json=repositoryUrl,proto3" json:"repository_url,omitempty"`
	ApplicationCreator    string                      `protobuf:"bytes,8,opt,name=application_creator,json=applicationCreator,proto3" json:"application_creator,omitempty"`
	ApplicationProvider   string                      `protobuf:"bytes,9,opt,name=application_provider,json=applicationProvider,proto3" json:"application_provider,omitempty"`
	ApplicationMaintainer string                      `protobuf:"bytes,10,opt,name=application_maintainer,json=applicationMaintainer,proto3" json:"application_maintainer,omitempty"`
	DateCreated           *time.Time                  `protobuf:"bytes,11,opt,name=date_created,json=dateCreated,proto3,stdtime" json:"date_created,omitempty"`
	Versions              []*VersionedApplicationSpec `protobuf:"bytes,12,rep,name=versions,proto3" json:"versions,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                    `json:"-"`
	XXX_unrecognized      []byte                      `json:"-"`
	XXX_sizecache         int32                       `json:"-"`
}

func (m *ApplicationSpec) Reset()         { *m = ApplicationSpec{} }
func (m *ApplicationSpec) String() string { return proto.CompactTextString(m) }
func (*ApplicationSpec) ProtoMessage()    {}
func (*ApplicationSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{0}
}
func (m *ApplicationSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ApplicationSpec.Unmarshal(m, b)
}
func (m *ApplicationSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ApplicationSpec.Marshal(b, m, deterministic)
}
func (m *ApplicationSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplicationSpec.Merge(m, src)
}
func (m *ApplicationSpec) XXX_Size() int {
	return xxx_messageInfo_ApplicationSpec.Size(m)
}
func (m *ApplicationSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplicationSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ApplicationSpec proto.InternalMessageInfo

func (m *ApplicationSpec) GetType() ApplicationType {
	if m != nil {
		return m.Type
	}
	return ApplicationType_EXTENSION
}

func (m *ApplicationSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ApplicationSpec) GetLogoUrl() string {
	if m != nil {
		return m.LogoUrl
	}
	return ""
}

func (m *ApplicationSpec) GetShortDescription() string {
	if m != nil {
		return m.ShortDescription
	}
	return ""
}

func (m *ApplicationSpec) GetLongDescription() string {
	if m != nil {
		return m.LongDescription
	}
	return ""
}

func (m *ApplicationSpec) GetDocumentationUrl() string {
	if m != nil {
		return m.DocumentationUrl
	}
	return ""
}

func (m *ApplicationSpec) GetRepositoryUrl() string {
	if m != nil {
		return m.RepositoryUrl
	}
	return ""
}

func (m *ApplicationSpec) GetApplicationCreator() string {
	if m != nil {
		return m.ApplicationCreator
	}
	return ""
}

func (m *ApplicationSpec) GetApplicationProvider() string {
	if m != nil {
		return m.ApplicationProvider
	}
	return ""
}

func (m *ApplicationSpec) GetApplicationMaintainer() string {
	if m != nil {
		return m.ApplicationMaintainer
	}
	return ""
}

func (m *ApplicationSpec) GetDateCreated() *time.Time {
	if m != nil {
		return m.DateCreated
	}
	return nil
}

func (m *ApplicationSpec) GetVersions() []*VersionedApplicationSpec {
	if m != nil {
		return m.Versions
	}
	return nil
}

type ApplicationSpecs struct {
	Specs                []*ApplicationSpec `protobuf:"bytes,1,rep,name=specs,proto3" json:"specs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ApplicationSpecs) Reset()         { *m = ApplicationSpecs{} }
func (m *ApplicationSpecs) String() string { return proto.CompactTextString(m) }
func (*ApplicationSpecs) ProtoMessage()    {}
func (*ApplicationSpecs) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{1}
}
func (m *ApplicationSpecs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ApplicationSpecs.Unmarshal(m, b)
}
func (m *ApplicationSpecs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ApplicationSpecs.Marshal(b, m, deterministic)
}
func (m *ApplicationSpecs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplicationSpecs.Merge(m, src)
}
func (m *ApplicationSpecs) XXX_Size() int {
	return xxx_messageInfo_ApplicationSpecs.Size(m)
}
func (m *ApplicationSpecs) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplicationSpecs.DiscardUnknown(m)
}

var xxx_messageInfo_ApplicationSpecs proto.InternalMessageInfo

func (m *ApplicationSpecs) GetSpecs() []*ApplicationSpec {
	if m != nil {
		return m.Specs
	}
	return nil
}

// Represents a specific version of an extension.
type VersionedApplicationSpec struct {
	// The version of the application
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// The date this version of the application was published
	DatePublished *time.Time `protobuf:"bytes,2,opt,name=date_published,json=datePublished,proto3,stdtime" json:"date_published,omitempty"`
	// Location of the Helm chart that will be used to install this application
	//
	// Types that are valid to be assigned to InstallationSpec:
	//	*VersionedApplicationSpec_GithubChart
	//	*VersionedApplicationSpec_HelmArchive
	//	*VersionedApplicationSpec_ManifestsArchive
	//	*VersionedApplicationSpec_InstallationSteps
	InstallationSpec isVersionedApplicationSpec_InstallationSpec `protobuf_oneof:"installation_spec"`
	// Optional default values yaml; if none provided, chart default will be used
	ValuesYaml string `protobuf:"bytes,30,opt,name=values_yaml,json=valuesYaml,proto3" json:"values_yaml,omitempty"`
	// Optional filter on the resources that should be considered part of the install, to handle cases
	// where a single chart can be used to deploy many applications (i.e. Istio chart deploys Kiali)
	RequiredLabels map[string]string `protobuf:"bytes,31,rep,name=required_labels,json=requiredLabels,proto3" json:"required_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Mesh-specific modifications to the extension installation manifest.
	Flavors []*Flavor `protobuf:"bytes,40,rep,name=flavors,proto3" json:"flavors,omitempty"`
	// Manifest render parameters that apply to all flavors of this version
	Parameters           []*Parameter `protobuf:"bytes,41,rep,name=parameters,proto3" json:"parameters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *VersionedApplicationSpec) Reset()         { *m = VersionedApplicationSpec{} }
func (m *VersionedApplicationSpec) String() string { return proto.CompactTextString(m) }
func (*VersionedApplicationSpec) ProtoMessage()    {}
func (*VersionedApplicationSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{2}
}
func (m *VersionedApplicationSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VersionedApplicationSpec.Unmarshal(m, b)
}
func (m *VersionedApplicationSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VersionedApplicationSpec.Marshal(b, m, deterministic)
}
func (m *VersionedApplicationSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionedApplicationSpec.Merge(m, src)
}
func (m *VersionedApplicationSpec) XXX_Size() int {
	return xxx_messageInfo_VersionedApplicationSpec.Size(m)
}
func (m *VersionedApplicationSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionedApplicationSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VersionedApplicationSpec proto.InternalMessageInfo

type isVersionedApplicationSpec_InstallationSpec interface {
	isVersionedApplicationSpec_InstallationSpec()
	Equal(interface{}) bool
}

type VersionedApplicationSpec_GithubChart struct {
	GithubChart *GithubRepositoryLocation `protobuf:"bytes,13,opt,name=github_chart,json=githubChart,proto3,oneof"`
}
type VersionedApplicationSpec_HelmArchive struct {
	HelmArchive *TgzLocation `protobuf:"bytes,14,opt,name=helm_archive,json=helmArchive,proto3,oneof"`
}
type VersionedApplicationSpec_ManifestsArchive struct {
	ManifestsArchive *TgzLocation `protobuf:"bytes,15,opt,name=manifests_archive,json=manifestsArchive,proto3,oneof"`
}
type VersionedApplicationSpec_InstallationSteps struct {
	InstallationSteps *InstallationSteps `protobuf:"bytes,16,opt,name=installation_steps,json=installationSteps,proto3,oneof"`
}

func (*VersionedApplicationSpec_GithubChart) isVersionedApplicationSpec_InstallationSpec()       {}
func (*VersionedApplicationSpec_HelmArchive) isVersionedApplicationSpec_InstallationSpec()       {}
func (*VersionedApplicationSpec_ManifestsArchive) isVersionedApplicationSpec_InstallationSpec()  {}
func (*VersionedApplicationSpec_InstallationSteps) isVersionedApplicationSpec_InstallationSpec() {}

func (m *VersionedApplicationSpec) GetInstallationSpec() isVersionedApplicationSpec_InstallationSpec {
	if m != nil {
		return m.InstallationSpec
	}
	return nil
}

func (m *VersionedApplicationSpec) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *VersionedApplicationSpec) GetDatePublished() *time.Time {
	if m != nil {
		return m.DatePublished
	}
	return nil
}

func (m *VersionedApplicationSpec) GetGithubChart() *GithubRepositoryLocation {
	if x, ok := m.GetInstallationSpec().(*VersionedApplicationSpec_GithubChart); ok {
		return x.GithubChart
	}
	return nil
}

func (m *VersionedApplicationSpec) GetHelmArchive() *TgzLocation {
	if x, ok := m.GetInstallationSpec().(*VersionedApplicationSpec_HelmArchive); ok {
		return x.HelmArchive
	}
	return nil
}

func (m *VersionedApplicationSpec) GetManifestsArchive() *TgzLocation {
	if x, ok := m.GetInstallationSpec().(*VersionedApplicationSpec_ManifestsArchive); ok {
		return x.ManifestsArchive
	}
	return nil
}

func (m *VersionedApplicationSpec) GetInstallationSteps() *InstallationSteps {
	if x, ok := m.GetInstallationSpec().(*VersionedApplicationSpec_InstallationSteps); ok {
		return x.InstallationSteps
	}
	return nil
}

func (m *VersionedApplicationSpec) GetValuesYaml() string {
	if m != nil {
		return m.ValuesYaml
	}
	return ""
}

func (m *VersionedApplicationSpec) GetRequiredLabels() map[string]string {
	if m != nil {
		return m.RequiredLabels
	}
	return nil
}

func (m *VersionedApplicationSpec) GetFlavors() []*Flavor {
	if m != nil {
		return m.Flavors
	}
	return nil
}

func (m *VersionedApplicationSpec) GetParameters() []*Parameter {
	if m != nil {
		return m.Parameters
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*VersionedApplicationSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _VersionedApplicationSpec_OneofMarshaler, _VersionedApplicationSpec_OneofUnmarshaler, _VersionedApplicationSpec_OneofSizer, []interface{}{
		(*VersionedApplicationSpec_GithubChart)(nil),
		(*VersionedApplicationSpec_HelmArchive)(nil),
		(*VersionedApplicationSpec_ManifestsArchive)(nil),
		(*VersionedApplicationSpec_InstallationSteps)(nil),
	}
}

func _VersionedApplicationSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*VersionedApplicationSpec)
	// installation_spec
	switch x := m.InstallationSpec.(type) {
	case *VersionedApplicationSpec_GithubChart:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GithubChart); err != nil {
			return err
		}
	case *VersionedApplicationSpec_HelmArchive:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HelmArchive); err != nil {
			return err
		}
	case *VersionedApplicationSpec_ManifestsArchive:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ManifestsArchive); err != nil {
			return err
		}
	case *VersionedApplicationSpec_InstallationSteps:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InstallationSteps); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("VersionedApplicationSpec.InstallationSpec has unexpected type %T", x)
	}
	return nil
}

func _VersionedApplicationSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*VersionedApplicationSpec)
	switch tag {
	case 13: // installation_spec.github_chart
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GithubRepositoryLocation)
		err := b.DecodeMessage(msg)
		m.InstallationSpec = &VersionedApplicationSpec_GithubChart{msg}
		return true, err
	case 14: // installation_spec.helm_archive
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TgzLocation)
		err := b.DecodeMessage(msg)
		m.InstallationSpec = &VersionedApplicationSpec_HelmArchive{msg}
		return true, err
	case 15: // installation_spec.manifests_archive
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TgzLocation)
		err := b.DecodeMessage(msg)
		m.InstallationSpec = &VersionedApplicationSpec_ManifestsArchive{msg}
		return true, err
	case 16: // installation_spec.installation_steps
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InstallationSteps)
		err := b.DecodeMessage(msg)
		m.InstallationSpec = &VersionedApplicationSpec_InstallationSteps{msg}
		return true, err
	default:
		return false, nil
	}
}

func _VersionedApplicationSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*VersionedApplicationSpec)
	// installation_spec
	switch x := m.InstallationSpec.(type) {
	case *VersionedApplicationSpec_GithubChart:
		s := proto.Size(x.GithubChart)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *VersionedApplicationSpec_HelmArchive:
		s := proto.Size(x.HelmArchive)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *VersionedApplicationSpec_ManifestsArchive:
		s := proto.Size(x.ManifestsArchive)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *VersionedApplicationSpec_InstallationSteps:
		s := proto.Size(x.InstallationSteps)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// InstallationSteps specify an installation procedure for Applications composed of multiple manifests.
// It may be desirable or necessary for an Application to be installed in stages, e.g. to run a pre-installation
// job or container before deploying other components.
// Resources will be applied to the Kubernetes cluster in the order they appear in the installation steps.
// Resources created from each step will be labeled with the step from which they were created.
// Finally, after each step is applied, any resources created by Flavor customizations will be created last.
type InstallationSteps struct {
	// an ordered list of installation steps
	Steps                []*InstallationSteps_Step `protobuf:"bytes,1,rep,name=steps,proto3" json:"steps,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *InstallationSteps) Reset()         { *m = InstallationSteps{} }
func (m *InstallationSteps) String() string { return proto.CompactTextString(m) }
func (*InstallationSteps) ProtoMessage()    {}
func (*InstallationSteps) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{3}
}
func (m *InstallationSteps) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InstallationSteps.Unmarshal(m, b)
}
func (m *InstallationSteps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InstallationSteps.Marshal(b, m, deterministic)
}
func (m *InstallationSteps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallationSteps.Merge(m, src)
}
func (m *InstallationSteps) XXX_Size() int {
	return xxx_messageInfo_InstallationSteps.Size(m)
}
func (m *InstallationSteps) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallationSteps.DiscardUnknown(m)
}

var xxx_messageInfo_InstallationSteps proto.InternalMessageInfo

func (m *InstallationSteps) GetSteps() []*InstallationSteps_Step {
	if m != nil {
		return m.Steps
	}
	return nil
}

type InstallationSteps_Step struct {
	// name of the installation step
	// each step must be uniquely named
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// Types that are valid to be assigned to Step:
	//	*InstallationSteps_Step_GithubChart
	//	*InstallationSteps_Step_HelmArchive
	//	*InstallationSteps_Step_ManifestsArchive
	Step                 isInstallationSteps_Step_Step `protobuf_oneof:"step"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *InstallationSteps_Step) Reset()         { *m = InstallationSteps_Step{} }
func (m *InstallationSteps_Step) String() string { return proto.CompactTextString(m) }
func (*InstallationSteps_Step) ProtoMessage()    {}
func (*InstallationSteps_Step) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{3, 0}
}
func (m *InstallationSteps_Step) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InstallationSteps_Step.Unmarshal(m, b)
}
func (m *InstallationSteps_Step) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InstallationSteps_Step.Marshal(b, m, deterministic)
}
func (m *InstallationSteps_Step) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallationSteps_Step.Merge(m, src)
}
func (m *InstallationSteps_Step) XXX_Size() int {
	return xxx_messageInfo_InstallationSteps_Step.Size(m)
}
func (m *InstallationSteps_Step) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallationSteps_Step.DiscardUnknown(m)
}

var xxx_messageInfo_InstallationSteps_Step proto.InternalMessageInfo

type isInstallationSteps_Step_Step interface {
	isInstallationSteps_Step_Step()
	Equal(interface{}) bool
}

type InstallationSteps_Step_GithubChart struct {
	GithubChart *GithubRepositoryLocation `protobuf:"bytes,1,opt,name=github_chart,json=githubChart,proto3,oneof"`
}
type InstallationSteps_Step_HelmArchive struct {
	HelmArchive *TgzLocation `protobuf:"bytes,2,opt,name=helm_archive,json=helmArchive,proto3,oneof"`
}
type InstallationSteps_Step_ManifestsArchive struct {
	ManifestsArchive *TgzLocation `protobuf:"bytes,3,opt,name=manifests_archive,json=manifestsArchive,proto3,oneof"`
}

func (*InstallationSteps_Step_GithubChart) isInstallationSteps_Step_Step()      {}
func (*InstallationSteps_Step_HelmArchive) isInstallationSteps_Step_Step()      {}
func (*InstallationSteps_Step_ManifestsArchive) isInstallationSteps_Step_Step() {}

func (m *InstallationSteps_Step) GetStep() isInstallationSteps_Step_Step {
	if m != nil {
		return m.Step
	}
	return nil
}

func (m *InstallationSteps_Step) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *InstallationSteps_Step) GetGithubChart() *GithubRepositoryLocation {
	if x, ok := m.GetStep().(*InstallationSteps_Step_GithubChart); ok {
		return x.GithubChart
	}
	return nil
}

func (m *InstallationSteps_Step) GetHelmArchive() *TgzLocation {
	if x, ok := m.GetStep().(*InstallationSteps_Step_HelmArchive); ok {
		return x.HelmArchive
	}
	return nil
}

func (m *InstallationSteps_Step) GetManifestsArchive() *TgzLocation {
	if x, ok := m.GetStep().(*InstallationSteps_Step_ManifestsArchive); ok {
		return x.ManifestsArchive
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InstallationSteps_Step) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InstallationSteps_Step_OneofMarshaler, _InstallationSteps_Step_OneofUnmarshaler, _InstallationSteps_Step_OneofSizer, []interface{}{
		(*InstallationSteps_Step_GithubChart)(nil),
		(*InstallationSteps_Step_HelmArchive)(nil),
		(*InstallationSteps_Step_ManifestsArchive)(nil),
	}
}

func _InstallationSteps_Step_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InstallationSteps_Step)
	// step
	switch x := m.Step.(type) {
	case *InstallationSteps_Step_GithubChart:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GithubChart); err != nil {
			return err
		}
	case *InstallationSteps_Step_HelmArchive:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HelmArchive); err != nil {
			return err
		}
	case *InstallationSteps_Step_ManifestsArchive:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ManifestsArchive); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InstallationSteps_Step.Step has unexpected type %T", x)
	}
	return nil
}

func _InstallationSteps_Step_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InstallationSteps_Step)
	switch tag {
	case 1: // step.github_chart
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GithubRepositoryLocation)
		err := b.DecodeMessage(msg)
		m.Step = &InstallationSteps_Step_GithubChart{msg}
		return true, err
	case 2: // step.helm_archive
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TgzLocation)
		err := b.DecodeMessage(msg)
		m.Step = &InstallationSteps_Step_HelmArchive{msg}
		return true, err
	case 3: // step.manifests_archive
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TgzLocation)
		err := b.DecodeMessage(msg)
		m.Step = &InstallationSteps_Step_ManifestsArchive{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InstallationSteps_Step_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InstallationSteps_Step)
	// step
	switch x := m.Step.(type) {
	case *InstallationSteps_Step_GithubChart:
		s := proto.Size(x.GithubChart)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InstallationSteps_Step_HelmArchive:
		s := proto.Size(x.HelmArchive)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InstallationSteps_Step_ManifestsArchive:
		s := proto.Size(x.ManifestsArchive)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A flavor represents a particular variant of an extension.
type Flavor struct {
	// Identifier of the flavor
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// This field should contain a clear description of what this flavor is intended to accomplish.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Optional customizations that are to be applied to the installation manifest.
	CustomizationLayers []*Layer `protobuf:"bytes,3,rep,name=customization_layers,json=customizationLayers,proto3" json:"customization_layers,omitempty"`
	// The flavor is considered applicable if any of the specified requirement sets is satisfied.
	RequirementSets      []*RequirementSet `protobuf:"bytes,4,rep,name=requirement_sets,json=requirementSets,proto3" json:"requirement_sets,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Flavor) Reset()         { *m = Flavor{} }
func (m *Flavor) String() string { return proto.CompactTextString(m) }
func (*Flavor) ProtoMessage()    {}
func (*Flavor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{4}
}
func (m *Flavor) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Flavor.Unmarshal(m, b)
}
func (m *Flavor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Flavor.Marshal(b, m, deterministic)
}
func (m *Flavor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Flavor.Merge(m, src)
}
func (m *Flavor) XXX_Size() int {
	return xxx_messageInfo_Flavor.Size(m)
}
func (m *Flavor) XXX_DiscardUnknown() {
	xxx_messageInfo_Flavor.DiscardUnknown(m)
}

var xxx_messageInfo_Flavor proto.InternalMessageInfo

func (m *Flavor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Flavor) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Flavor) GetCustomizationLayers() []*Layer {
	if m != nil {
		return m.CustomizationLayers
	}
	return nil
}

func (m *Flavor) GetRequirementSets() []*RequirementSet {
	if m != nil {
		return m.RequirementSets
	}
	return nil
}

// Parameters represent values that are used to configure the installation of an extension.
type Parameter struct {
	// Identifier of the parameter
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Description of what the effects of the parameter are.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Value of the parameter
	Value *ParameterValue `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	// Default value of the parameter
	Default *ParameterValue `protobuf:"bytes,4,opt,name=default,proto3" json:"default,omitempty"`
	// Indicates whether a value for the parameter is required for the installation of the extension
	// to be performed.
	Required bool `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
	// User-friendly display name of the parameter
	DisplayName          string   `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Parameter) Reset()         { *m = Parameter{} }
func (m *Parameter) String() string { return proto.CompactTextString(m) }
func (*Parameter) ProtoMessage()    {}
func (*Parameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{5}
}
func (m *Parameter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Parameter.Unmarshal(m, b)
}
func (m *Parameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Parameter.Marshal(b, m, deterministic)
}
func (m *Parameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Parameter.Merge(m, src)
}
func (m *Parameter) XXX_Size() int {
	return xxx_messageInfo_Parameter.Size(m)
}
func (m *Parameter) XXX_DiscardUnknown() {
	xxx_messageInfo_Parameter.DiscardUnknown(m)
}

var xxx_messageInfo_Parameter proto.InternalMessageInfo

func (m *Parameter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Parameter) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Parameter) GetValue() *ParameterValue {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Parameter) GetDefault() *ParameterValue {
	if m != nil {
		return m.Default
	}
	return nil
}

func (m *Parameter) GetRequired() bool {
	if m != nil {
		return m.Required
	}
	return false
}

func (m *Parameter) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

type ParameterValue struct {
	// Types that are valid to be assigned to Type:
	//	*ParameterValue_String_
	//	*ParameterValue_Float
	//	*ParameterValue_Bool
	//	*ParameterValue_Int
	//	*ParameterValue_Date
	//	*ParameterValue_Secret
	Type                 isParameterValue_Type `protobuf_oneof:"type"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ParameterValue) Reset()         { *m = ParameterValue{} }
func (m *ParameterValue) String() string { return proto.CompactTextString(m) }
func (*ParameterValue) ProtoMessage()    {}
func (*ParameterValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{6}
}
func (m *ParameterValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ParameterValue.Unmarshal(m, b)
}
func (m *ParameterValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ParameterValue.Marshal(b, m, deterministic)
}
func (m *ParameterValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParameterValue.Merge(m, src)
}
func (m *ParameterValue) XXX_Size() int {
	return xxx_messageInfo_ParameterValue.Size(m)
}
func (m *ParameterValue) XXX_DiscardUnknown() {
	xxx_messageInfo_ParameterValue.DiscardUnknown(m)
}

var xxx_messageInfo_ParameterValue proto.InternalMessageInfo

type isParameterValue_Type interface {
	isParameterValue_Type()
	Equal(interface{}) bool
}

type ParameterValue_String_ struct {
	String_ string `protobuf:"bytes,1,opt,name=string,proto3,oneof"`
}
type ParameterValue_Float struct {
	Float float32 `protobuf:"fixed32,2,opt,name=float,proto3,oneof"`
}
type ParameterValue_Bool struct {
	Bool bool `protobuf:"varint,3,opt,name=bool,proto3,oneof"`
}
type ParameterValue_Int struct {
	Int int64 `protobuf:"varint,4,opt,name=int,proto3,oneof"`
}
type ParameterValue_Date struct {
	Date *time.Time `protobuf:"bytes,5,opt,name=date,proto3,oneof,stdtime"`
}
type ParameterValue_Secret struct {
	Secret *SecretValue `protobuf:"bytes,6,opt,name=secret,proto3,oneof"`
}

func (*ParameterValue_String_) isParameterValue_Type() {}
func (*ParameterValue_Float) isParameterValue_Type()   {}
func (*ParameterValue_Bool) isParameterValue_Type()    {}
func (*ParameterValue_Int) isParameterValue_Type()     {}
func (*ParameterValue_Date) isParameterValue_Type()    {}
func (*ParameterValue_Secret) isParameterValue_Type()  {}

func (m *ParameterValue) GetType() isParameterValue_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *ParameterValue) GetString_() string {
	if x, ok := m.GetType().(*ParameterValue_String_); ok {
		return x.String_
	}
	return ""
}

func (m *ParameterValue) GetFloat() float32 {
	if x, ok := m.GetType().(*ParameterValue_Float); ok {
		return x.Float
	}
	return 0
}

func (m *ParameterValue) GetBool() bool {
	if x, ok := m.GetType().(*ParameterValue_Bool); ok {
		return x.Bool
	}
	return false
}

func (m *ParameterValue) GetInt() int64 {
	if x, ok := m.GetType().(*ParameterValue_Int); ok {
		return x.Int
	}
	return 0
}

func (m *ParameterValue) GetDate() *time.Time {
	if x, ok := m.GetType().(*ParameterValue_Date); ok {
		return x.Date
	}
	return nil
}

func (m *ParameterValue) GetSecret() *SecretValue {
	if x, ok := m.GetType().(*ParameterValue_Secret); ok {
		return x.Secret
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ParameterValue) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ParameterValue_OneofMarshaler, _ParameterValue_OneofUnmarshaler, _ParameterValue_OneofSizer, []interface{}{
		(*ParameterValue_String_)(nil),
		(*ParameterValue_Float)(nil),
		(*ParameterValue_Bool)(nil),
		(*ParameterValue_Int)(nil),
		(*ParameterValue_Date)(nil),
		(*ParameterValue_Secret)(nil),
	}
}

func _ParameterValue_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ParameterValue)
	// type
	switch x := m.Type.(type) {
	case *ParameterValue_String_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.String_)
	case *ParameterValue_Float:
		_ = b.EncodeVarint(2<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(math.Float32bits(x.Float)))
	case *ParameterValue_Bool:
		t := uint64(0)
		if x.Bool {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *ParameterValue_Int:
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Int))
	case *ParameterValue_Date:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		dAtA, err := github_com_gogo_protobuf_types.StdTimeMarshal(*x.Date)
		if err != nil {
			return err
		}
		if err := b.EncodeRawBytes(dAtA); err != nil {
			return err
		}
	case *ParameterValue_Secret:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Secret); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ParameterValue.Type has unexpected type %T", x)
	}
	return nil
}

func _ParameterValue_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ParameterValue)
	switch tag {
	case 1: // type.string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Type = &ParameterValue_String_{x}
		return true, err
	case 2: // type.float
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.Type = &ParameterValue_Float{math.Float32frombits(uint32(x))}
		return true, err
	case 3: // type.bool
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &ParameterValue_Bool{x != 0}
		return true, err
	case 4: // type.int
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &ParameterValue_Int{int64(x)}
		return true, err
	case 5: // type.date
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		if err != nil {
			return true, err
		}
		c := new(time.Time)
		if err2 := github_com_gogo_protobuf_types.StdTimeUnmarshal(c, x); err2 != nil {
			return true, err
		}
		m.Type = &ParameterValue_Date{c}
		return true, err
	case 6: // type.secret
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SecretValue)
		err := b.DecodeMessage(msg)
		m.Type = &ParameterValue_Secret{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ParameterValue_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ParameterValue)
	// type
	switch x := m.Type.(type) {
	case *ParameterValue_String_:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.String_)))
		n += len(x.String_)
	case *ParameterValue_Float:
		n += 1 // tag and wire
		n += 4
	case *ParameterValue_Bool:
		n += 1 // tag and wire
		n += 1
	case *ParameterValue_Int:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Int))
	case *ParameterValue_Date:
		s := github_com_gogo_protobuf_types.SizeOfStdTime(*x.Date)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ParameterValue_Secret:
		s := proto.Size(x.Secret)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SecretValue struct {
	// Namespace and name of the Kubernetes secret containing the value
	Ref *core.ResourceRef `protobuf:"bytes,1,opt,name=ref,proto3" json:"ref,omitempty"`
	// Key for the desired value within the secret's data map.
	Key                  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SecretValue) Reset()         { *m = SecretValue{} }
func (m *SecretValue) String() string { return proto.CompactTextString(m) }
func (*SecretValue) ProtoMessage()    {}
func (*SecretValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{7}
}
func (m *SecretValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SecretValue.Unmarshal(m, b)
}
func (m *SecretValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SecretValue.Marshal(b, m, deterministic)
}
func (m *SecretValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecretValue.Merge(m, src)
}
func (m *SecretValue) XXX_Size() int {
	return xxx_messageInfo_SecretValue.Size(m)
}
func (m *SecretValue) XXX_DiscardUnknown() {
	xxx_messageInfo_SecretValue.DiscardUnknown(m)
}

var xxx_messageInfo_SecretValue proto.InternalMessageInfo

func (m *SecretValue) GetRef() *core.ResourceRef {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *SecretValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// A layer represent optional processing steps that can be executed to apply mesh-specific transformations to
// the rendered extension installation manifest.
type Layer struct {
	// A unique identifier for the layer, i.e. "mtls"
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// A user-friendly name of the layer, i.e. "Mutual TLS Settings"
	DisplayName string `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// If true, this layer can be flagged on or off for rendering.
	Optional bool `protobuf:"varint,3,opt,name=optional,proto3" json:"optional,omitempty"`
	// One or more variants for this configuration layer, one of which will be chosen by the user.
	Options []*LayerOption `protobuf:"bytes,4,rep,name=options,proto3" json:"options,omitempty"`
	// Optional set of parameters to be applied to the layer.
	Parameters           []*Parameter `protobuf:"bytes,5,rep,name=parameters,proto3" json:"parameters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Layer) Reset()         { *m = Layer{} }
func (m *Layer) String() string { return proto.CompactTextString(m) }
func (*Layer) ProtoMessage()    {}
func (*Layer) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{8}
}
func (m *Layer) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Layer.Unmarshal(m, b)
}
func (m *Layer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Layer.Marshal(b, m, deterministic)
}
func (m *Layer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Layer.Merge(m, src)
}
func (m *Layer) XXX_Size() int {
	return xxx_messageInfo_Layer.Size(m)
}
func (m *Layer) XXX_DiscardUnknown() {
	xxx_messageInfo_Layer.DiscardUnknown(m)
}

var xxx_messageInfo_Layer proto.InternalMessageInfo

func (m *Layer) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Layer) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *Layer) GetOptional() bool {
	if m != nil {
		return m.Optional
	}
	return false
}

func (m *Layer) GetOptions() []*LayerOption {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *Layer) GetParameters() []*Parameter {
	if m != nil {
		return m.Parameters
	}
	return nil
}

// One option for configuring a layer. At least one of the kustomize or helm values should be set, or the layer
// will be a no-op during rendering.
type LayerOption struct {
	// Unique identifier for the layer option, i.e. "strict"
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// A user-friendly name
	DisplayName string `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// A user-friendly description
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// A kustomize overlay
	Kustomize *Kustomize `protobuf:"bytes,4,opt,name=kustomize,proto3" json:"kustomize,omitempty"`
	// A set of value overrides
	HelmValues           string   `protobuf:"bytes,5,opt,name=helm_values,json=helmValues,proto3" json:"helm_values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LayerOption) Reset()         { *m = LayerOption{} }
func (m *LayerOption) String() string { return proto.CompactTextString(m) }
func (*LayerOption) ProtoMessage()    {}
func (*LayerOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{9}
}
func (m *LayerOption) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LayerOption.Unmarshal(m, b)
}
func (m *LayerOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LayerOption.Marshal(b, m, deterministic)
}
func (m *LayerOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LayerOption.Merge(m, src)
}
func (m *LayerOption) XXX_Size() int {
	return xxx_messageInfo_LayerOption.Size(m)
}
func (m *LayerOption) XXX_DiscardUnknown() {
	xxx_messageInfo_LayerOption.DiscardUnknown(m)
}

var xxx_messageInfo_LayerOption proto.InternalMessageInfo

func (m *LayerOption) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *LayerOption) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *LayerOption) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *LayerOption) GetKustomize() *Kustomize {
	if m != nil {
		return m.Kustomize
	}
	return nil
}

func (m *LayerOption) GetHelmValues() string {
	if m != nil {
		return m.HelmValues
	}
	return ""
}

// Represents a layer implemented via [kustomize](https://github.com/kubernetes-sigs/kustomize)
type Kustomize struct {
	// Location of the root of the kustomize directory structure
	//
	// Types that are valid to be assigned to Location:
	//	*Kustomize_Github
	//	*Kustomize_TgzArchive
	Location isKustomize_Location `protobuf_oneof:"location"`
	// Path to the overlay overlay that will be applied to the base (the rendered installation manifest).
	OverlayPath          string   `protobuf:"bytes,3,opt,name=overlay_path,json=overlayPath,proto3" json:"overlay_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Kustomize) Reset()         { *m = Kustomize{} }
func (m *Kustomize) String() string { return proto.CompactTextString(m) }
func (*Kustomize) ProtoMessage()    {}
func (*Kustomize) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{10}
}
func (m *Kustomize) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Kustomize.Unmarshal(m, b)
}
func (m *Kustomize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Kustomize.Marshal(b, m, deterministic)
}
func (m *Kustomize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Kustomize.Merge(m, src)
}
func (m *Kustomize) XXX_Size() int {
	return xxx_messageInfo_Kustomize.Size(m)
}
func (m *Kustomize) XXX_DiscardUnknown() {
	xxx_messageInfo_Kustomize.DiscardUnknown(m)
}

var xxx_messageInfo_Kustomize proto.InternalMessageInfo

type isKustomize_Location interface {
	isKustomize_Location()
	Equal(interface{}) bool
}

type Kustomize_Github struct {
	Github *GithubRepositoryLocation `protobuf:"bytes,1,opt,name=github,proto3,oneof"`
}
type Kustomize_TgzArchive struct {
	TgzArchive *TgzLocation `protobuf:"bytes,2,opt,name=tgz_archive,json=tgzArchive,proto3,oneof"`
}

func (*Kustomize_Github) isKustomize_Location()     {}
func (*Kustomize_TgzArchive) isKustomize_Location() {}

func (m *Kustomize) GetLocation() isKustomize_Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Kustomize) GetGithub() *GithubRepositoryLocation {
	if x, ok := m.GetLocation().(*Kustomize_Github); ok {
		return x.Github
	}
	return nil
}

func (m *Kustomize) GetTgzArchive() *TgzLocation {
	if x, ok := m.GetLocation().(*Kustomize_TgzArchive); ok {
		return x.TgzArchive
	}
	return nil
}

func (m *Kustomize) GetOverlayPath() string {
	if m != nil {
		return m.OverlayPath
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Kustomize) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Kustomize_OneofMarshaler, _Kustomize_OneofUnmarshaler, _Kustomize_OneofSizer, []interface{}{
		(*Kustomize_Github)(nil),
		(*Kustomize_TgzArchive)(nil),
	}
}

func _Kustomize_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Kustomize)
	// location
	switch x := m.Location.(type) {
	case *Kustomize_Github:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Github); err != nil {
			return err
		}
	case *Kustomize_TgzArchive:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TgzArchive); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Kustomize.Location has unexpected type %T", x)
	}
	return nil
}

func _Kustomize_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Kustomize)
	switch tag {
	case 1: // location.github
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GithubRepositoryLocation)
		err := b.DecodeMessage(msg)
		m.Location = &Kustomize_Github{msg}
		return true, err
	case 2: // location.tgz_archive
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TgzLocation)
		err := b.DecodeMessage(msg)
		m.Location = &Kustomize_TgzArchive{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Kustomize_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Kustomize)
	// location
	switch x := m.Location.(type) {
	case *Kustomize_Github:
		s := proto.Size(x.Github)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Kustomize_TgzArchive:
		s := proto.Size(x.TgzArchive)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Wraps a collection of FlavorCompatibilityInfo
type FlavorCompatibility struct {
	CompatiblePairs      []*CompatibleFlavorMeshPair `protobuf:"bytes,1,rep,name=compatible_pairs,json=compatiblePairs,proto3" json:"compatible_pairs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *FlavorCompatibility) Reset()         { *m = FlavorCompatibility{} }
func (m *FlavorCompatibility) String() string { return proto.CompactTextString(m) }
func (*FlavorCompatibility) ProtoMessage()    {}
func (*FlavorCompatibility) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{11}
}
func (m *FlavorCompatibility) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FlavorCompatibility.Unmarshal(m, b)
}
func (m *FlavorCompatibility) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FlavorCompatibility.Marshal(b, m, deterministic)
}
func (m *FlavorCompatibility) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlavorCompatibility.Merge(m, src)
}
func (m *FlavorCompatibility) XXX_Size() int {
	return xxx_messageInfo_FlavorCompatibility.Size(m)
}
func (m *FlavorCompatibility) XXX_DiscardUnknown() {
	xxx_messageInfo_FlavorCompatibility.DiscardUnknown(m)
}

var xxx_messageInfo_FlavorCompatibility proto.InternalMessageInfo

func (m *FlavorCompatibility) GetCompatiblePairs() []*CompatibleFlavorMeshPair {
	if m != nil {
		return m.CompatiblePairs
	}
	return nil
}

// Represents a Flavor and a Mesh instance that are compatible with one another.
type CompatibleFlavorMeshPair struct {
	Flavor               *Flavor           `protobuf:"bytes,1,opt,name=flavor,proto3" json:"flavor,omitempty"`
	Mesh                 *core.ResourceRef `protobuf:"bytes,2,opt,name=mesh,proto3" json:"mesh,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *CompatibleFlavorMeshPair) Reset()         { *m = CompatibleFlavorMeshPair{} }
func (m *CompatibleFlavorMeshPair) String() string { return proto.CompactTextString(m) }
func (*CompatibleFlavorMeshPair) ProtoMessage()    {}
func (*CompatibleFlavorMeshPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{12}
}
func (m *CompatibleFlavorMeshPair) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CompatibleFlavorMeshPair.Unmarshal(m, b)
}
func (m *CompatibleFlavorMeshPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CompatibleFlavorMeshPair.Marshal(b, m, deterministic)
}
func (m *CompatibleFlavorMeshPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompatibleFlavorMeshPair.Merge(m, src)
}
func (m *CompatibleFlavorMeshPair) XXX_Size() int {
	return xxx_messageInfo_CompatibleFlavorMeshPair.Size(m)
}
func (m *CompatibleFlavorMeshPair) XXX_DiscardUnknown() {
	xxx_messageInfo_CompatibleFlavorMeshPair.DiscardUnknown(m)
}

var xxx_messageInfo_CompatibleFlavorMeshPair proto.InternalMessageInfo

func (m *CompatibleFlavorMeshPair) GetFlavor() *Flavor {
	if m != nil {
		return m.Flavor
	}
	return nil
}

func (m *CompatibleFlavorMeshPair) GetMesh() *core.ResourceRef {
	if m != nil {
		return m.Mesh
	}
	return nil
}

// Represents a set of requirements that all need to be satisfied.
type RequirementSet struct {
	MeshRequirement      *MeshRequirement `protobuf:"bytes,1,opt,name=mesh_requirement,json=meshRequirement,proto3" json:"mesh_requirement,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *RequirementSet) Reset()         { *m = RequirementSet{} }
func (m *RequirementSet) String() string { return proto.CompactTextString(m) }
func (*RequirementSet) ProtoMessage()    {}
func (*RequirementSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{13}
}
func (m *RequirementSet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RequirementSet.Unmarshal(m, b)
}
func (m *RequirementSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RequirementSet.Marshal(b, m, deterministic)
}
func (m *RequirementSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequirementSet.Merge(m, src)
}
func (m *RequirementSet) XXX_Size() int {
	return xxx_messageInfo_RequirementSet.Size(m)
}
func (m *RequirementSet) XXX_DiscardUnknown() {
	xxx_messageInfo_RequirementSet.DiscardUnknown(m)
}

var xxx_messageInfo_RequirementSet proto.InternalMessageInfo

func (m *RequirementSet) GetMeshRequirement() *MeshRequirement {
	if m != nil {
		return m.MeshRequirement
	}
	return nil
}

// Represents the requirement for a mesh to be installed.
type MeshRequirement struct {
	// Type of mesh
	MeshType MeshType `protobuf:"varint,1,opt,name=mesh_type,json=meshType,proto3,enum=hub.solo.io.MeshType" json:"mesh_type,omitempty"`
	// Range of allowed versions. If empty, any version is allowed.
	Versions             *AllowedVersions `protobuf:"bytes,2,opt,name=versions,proto3" json:"versions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *MeshRequirement) Reset()         { *m = MeshRequirement{} }
func (m *MeshRequirement) String() string { return proto.CompactTextString(m) }
func (*MeshRequirement) ProtoMessage()    {}
func (*MeshRequirement) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{14}
}
func (m *MeshRequirement) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MeshRequirement.Unmarshal(m, b)
}
func (m *MeshRequirement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MeshRequirement.Marshal(b, m, deterministic)
}
func (m *MeshRequirement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeshRequirement.Merge(m, src)
}
func (m *MeshRequirement) XXX_Size() int {
	return xxx_messageInfo_MeshRequirement.Size(m)
}
func (m *MeshRequirement) XXX_DiscardUnknown() {
	xxx_messageInfo_MeshRequirement.DiscardUnknown(m)
}

var xxx_messageInfo_MeshRequirement proto.InternalMessageInfo

func (m *MeshRequirement) GetMeshType() MeshType {
	if m != nil {
		return m.MeshType
	}
	return MeshType_ISTIO
}

func (m *MeshRequirement) GetVersions() *AllowedVersions {
	if m != nil {
		return m.Versions
	}
	return nil
}

// A directory inside of a github repo
type GithubRepositoryLocation struct {
	Org                  string   `protobuf:"bytes,1,opt,name=org,proto3" json:"org,omitempty"`
	Repo                 string   `protobuf:"bytes,2,opt,name=repo,proto3" json:"repo,omitempty"`
	Ref                  string   `protobuf:"bytes,3,opt,name=ref,proto3" json:"ref,omitempty"`
	Directory            string   `protobuf:"bytes,4,opt,name=directory,proto3" json:"directory,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GithubRepositoryLocation) Reset()         { *m = GithubRepositoryLocation{} }
func (m *GithubRepositoryLocation) String() string { return proto.CompactTextString(m) }
func (*GithubRepositoryLocation) ProtoMessage()    {}
func (*GithubRepositoryLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{15}
}
func (m *GithubRepositoryLocation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GithubRepositoryLocation.Unmarshal(m, b)
}
func (m *GithubRepositoryLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GithubRepositoryLocation.Marshal(b, m, deterministic)
}
func (m *GithubRepositoryLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GithubRepositoryLocation.Merge(m, src)
}
func (m *GithubRepositoryLocation) XXX_Size() int {
	return xxx_messageInfo_GithubRepositoryLocation.Size(m)
}
func (m *GithubRepositoryLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_GithubRepositoryLocation.DiscardUnknown(m)
}

var xxx_messageInfo_GithubRepositoryLocation proto.InternalMessageInfo

func (m *GithubRepositoryLocation) GetOrg() string {
	if m != nil {
		return m.Org
	}
	return ""
}

func (m *GithubRepositoryLocation) GetRepo() string {
	if m != nil {
		return m.Repo
	}
	return ""
}

func (m *GithubRepositoryLocation) GetRef() string {
	if m != nil {
		return m.Ref
	}
	return ""
}

func (m *GithubRepositoryLocation) GetDirectory() string {
	if m != nil {
		return m.Directory
	}
	return ""
}

// Location of a gzipped tar file
type TgzLocation struct {
	Uri                  string   `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TgzLocation) Reset()         { *m = TgzLocation{} }
func (m *TgzLocation) String() string { return proto.CompactTextString(m) }
func (*TgzLocation) ProtoMessage()    {}
func (*TgzLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{16}
}
func (m *TgzLocation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TgzLocation.Unmarshal(m, b)
}
func (m *TgzLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TgzLocation.Marshal(b, m, deterministic)
}
func (m *TgzLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TgzLocation.Merge(m, src)
}
func (m *TgzLocation) XXX_Size() int {
	return xxx_messageInfo_TgzLocation.Size(m)
}
func (m *TgzLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_TgzLocation.DiscardUnknown(m)
}

var xxx_messageInfo_TgzLocation proto.InternalMessageInfo

func (m *TgzLocation) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

type AllowedVersions struct {
	MinVersion           string   `protobuf:"bytes,2,opt,name=min_version,json=minVersion,proto3" json:"min_version,omitempty"`
	MaxVersion           string   `protobuf:"bytes,3,opt,name=max_version,json=maxVersion,proto3" json:"max_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllowedVersions) Reset()         { *m = AllowedVersions{} }
func (m *AllowedVersions) String() string { return proto.CompactTextString(m) }
func (*AllowedVersions) ProtoMessage()    {}
func (*AllowedVersions) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{17}
}
func (m *AllowedVersions) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AllowedVersions.Unmarshal(m, b)
}
func (m *AllowedVersions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AllowedVersions.Marshal(b, m, deterministic)
}
func (m *AllowedVersions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllowedVersions.Merge(m, src)
}
func (m *AllowedVersions) XXX_Size() int {
	return xxx_messageInfo_AllowedVersions.Size(m)
}
func (m *AllowedVersions) XXX_DiscardUnknown() {
	xxx_messageInfo_AllowedVersions.DiscardUnknown(m)
}

var xxx_messageInfo_AllowedVersions proto.InternalMessageInfo

func (m *AllowedVersions) GetMinVersion() string {
	if m != nil {
		return m.MinVersion
	}
	return ""
}

func (m *AllowedVersions) GetMaxVersion() string {
	if m != nil {
		return m.MaxVersion
	}
	return ""
}

func init() {
	proto.RegisterEnum("hub.solo.io.ApplicationType", ApplicationType_name, ApplicationType_value)
	proto.RegisterEnum("hub.solo.io.MeshType", MeshType_name, MeshType_value)
	proto.RegisterType((*ApplicationSpec)(nil), "hub.solo.io.ApplicationSpec")
	proto.RegisterType((*ApplicationSpecs)(nil), "hub.solo.io.ApplicationSpecs")
	proto.RegisterType((*VersionedApplicationSpec)(nil), "hub.solo.io.VersionedApplicationSpec")
	proto.RegisterMapType((map[string]string)(nil), "hub.solo.io.VersionedApplicationSpec.RequiredLabelsEntry")
	proto.RegisterType((*InstallationSteps)(nil), "hub.solo.io.InstallationSteps")
	proto.RegisterType((*InstallationSteps_Step)(nil), "hub.solo.io.InstallationSteps.Step")
	proto.RegisterType((*Flavor)(nil), "hub.solo.io.Flavor")
	proto.RegisterType((*Parameter)(nil), "hub.solo.io.Parameter")
	proto.RegisterType((*ParameterValue)(nil), "hub.solo.io.ParameterValue")
	proto.RegisterType((*SecretValue)(nil), "hub.solo.io.SecretValue")
	proto.RegisterType((*Layer)(nil), "hub.solo.io.Layer")
	proto.RegisterType((*LayerOption)(nil), "hub.solo.io.LayerOption")
	proto.RegisterType((*Kustomize)(nil), "hub.solo.io.Kustomize")
	proto.RegisterType((*FlavorCompatibility)(nil), "hub.solo.io.FlavorCompatibility")
	proto.RegisterType((*CompatibleFlavorMeshPair)(nil), "hub.solo.io.CompatibleFlavorMeshPair")
	proto.RegisterType((*RequirementSet)(nil), "hub.solo.io.RequirementSet")
	proto.RegisterType((*MeshRequirement)(nil), "hub.solo.io.MeshRequirement")
	proto.RegisterType((*GithubRepositoryLocation)(nil), "hub.solo.io.GithubRepositoryLocation")
	proto.RegisterType((*TgzLocation)(nil), "hub.solo.io.TgzLocation")
	proto.RegisterType((*AllowedVersions)(nil), "hub.solo.io.AllowedVersions")
}

func init() { proto.RegisterFile("api/v1/registry.proto", fileDescriptor_d1ad3a89626d72ea) }

var fileDescriptor_d1ad3a89626d72ea = []byte{
	// 1564 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcd, 0x72, 0x1b, 0xb9,
	0x11, 0xe6, 0xf0, 0x4f, 0x64, 0x53, 0x22, 0x29, 0x48, 0x76, 0x8d, 0x65, 0x97, 0x25, 0x4f, 0xca,
	0x55, 0xb2, 0x15, 0x93, 0x91, 0x62, 0xbb, 0xec, 0xa4, 0x52, 0x29, 0x49, 0x96, 0x25, 0xc5, 0xfa,
	0x61, 0x0d, 0x15, 0x27, 0xce, 0x85, 0x05, 0x92, 0x20, 0x89, 0xf2, 0x0c, 0x31, 0x01, 0x40, 0xc6,
	0xd4, 0x25, 0xaf, 0x90, 0xc7, 0xc8, 0x23, 0x24, 0xc7, 0xe4, 0xb2, 0xa7, 0x7d, 0x86, 0xdd, 0xda,
	0xc3, 0x1e, 0xf6, 0x01, 0xf6, 0xbc, 0x05, 0x60, 0x86, 0x9a, 0xa1, 0x24, 0x5b, 0x76, 0xf9, 0x42,
	0xa2, 0xbb, 0xbf, 0x6e, 0x34, 0x1a, 0x1f, 0x1a, 0x18, 0xb8, 0x85, 0x03, 0x5a, 0x1f, 0x6f, 0xd6,
	0x39, 0xe9, 0x53, 0x21, 0xf9, 0xa4, 0x16, 0x70, 0x26, 0x19, 0x2a, 0x0d, 0x46, 0xed, 0x9a, 0x60,
	0x1e, 0xab, 0x51, 0xb6, 0xb2, 0xdc, 0x67, 0x7d, 0xa6, 0xf5, 0x75, 0x35, 0x32, 0x90, 0x95, 0xd5,
	0x3e, 0x63, 0x7d, 0x8f, 0xd4, 0xb5, 0xd4, 0x1e, 0xf5, 0xea, 0x92, 0xfa, 0x44, 0x48, 0xec, 0x07,
	0x21, 0xe0, 0xd7, 0x7d, 0x2a, 0x55, 0x98, 0x0e, 0xf3, 0xeb, 0x2a, 0xd4, 0x13, 0xca, 0xcc, 0xff,
	0x7b, 0x2a, 0xeb, 0xd3, 0x69, 0x7b, 0x06, 0xed, 0xfc, 0x2f, 0x0b, 0x95, 0xed, 0x20, 0xf0, 0x68,
	0x07, 0x4b, 0xca, 0x86, 0xcd, 0x80, 0x74, 0xd0, 0x6f, 0x20, 0x2b, 0x27, 0x01, 0xb1, 0xad, 0x35,
	0x6b, 0xbd, 0xbc, 0x75, 0xaf, 0x16, 0x4b, 0xaa, 0x16, 0xc3, 0x9e, 0x4d, 0x02, 0xe2, 0x6a, 0x24,
	0x42, 0x90, 0x1d, 0x62, 0x9f, 0xd8, 0xe9, 0x35, 0x6b, 0xbd, 0xe8, 0xea, 0x31, 0xba, 0x03, 0x05,
	0x8f, 0xf5, 0x59, 0x6b, 0xc4, 0x3d, 0x3b, 0xa3, 0xf5, 0x73, 0x4a, 0xfe, 0x33, 0xf7, 0xd0, 0x06,
	0x2c, 0x8a, 0x01, 0xe3, 0xb2, 0xd5, 0x25, 0xa2, 0xc3, 0x69, 0xa0, 0xa2, 0xd9, 0x59, 0x8d, 0xa9,
	0x6a, 0xc3, 0xab, 0x0b, 0x3d, 0x7a, 0x04, 0x55, 0x8f, 0x0d, 0xfb, 0x09, 0x6c, 0x4e, 0x63, 0x2b,
	0x4a, 0x1f, 0x87, 0x6e, 0xc0, 0x62, 0x97, 0x75, 0x46, 0x3e, 0x19, 0x4a, 0x9d, 0xa1, 0x9e, 0x3b,
	0x6f, 0xe2, 0x26, 0x0c, 0x2a, 0x89, 0x87, 0x50, 0xe6, 0x24, 0x60, 0x82, 0x4a, 0xc6, 0x27, 0x1a,
	0x39, 0xa7, 0x91, 0x0b, 0x17, 0x5a, 0x05, 0xab, 0xc3, 0x12, 0xbe, 0x58, 0x73, 0xab, 0xc3, 0x09,
	0x96, 0x8c, 0xdb, 0x05, 0x8d, 0x45, 0x31, 0xd3, 0xae, 0xb1, 0xa0, 0x4d, 0x58, 0x8e, 0x3b, 0x04,
	0x9c, 0x8d, 0x69, 0x97, 0x70, 0xbb, 0xa8, 0x3d, 0xe2, 0xc1, 0x1a, 0xa1, 0x09, 0x3d, 0x83, 0xdb,
	0x71, 0x17, 0x1f, 0xd3, 0xa1, 0xc4, 0x74, 0x48, 0xb8, 0x0d, 0xda, 0xe9, 0x56, 0xcc, 0x7a, 0x3c,
	0x35, 0xa2, 0x5d, 0x98, 0xef, 0x62, 0x49, 0x4c, 0x4e, 0xa4, 0x6b, 0x97, 0xd6, 0xac, 0xf5, 0xd2,
	0xd6, 0x4a, 0xcd, 0x30, 0xa4, 0x16, 0x31, 0xa4, 0x76, 0x16, 0x31, 0x64, 0x27, 0xfb, 0xaf, 0xef,
	0x56, 0x2d, 0xb7, 0xa4, 0xbc, 0x76, 0x8d, 0x13, 0xda, 0x86, 0xc2, 0x98, 0x70, 0x41, 0xd9, 0x50,
	0xd8, 0xf3, 0x6b, 0x99, 0xf5, 0xd2, 0xd6, 0xc3, 0xc4, 0x86, 0xbf, 0x35, 0x46, 0xd2, 0x9d, 0x61,
	0x89, 0x3b, 0x75, 0x73, 0x5e, 0x43, 0x75, 0xc6, 0x28, 0xd0, 0x16, 0xe4, 0x84, 0x1a, 0xd8, 0x96,
	0x8e, 0x79, 0x2d, 0x89, 0x74, 0x28, 0x03, 0x75, 0x7e, 0xcc, 0x81, 0x7d, 0xdd, 0x74, 0xc8, 0x86,
	0xb9, 0x70, 0x42, 0xcd, 0xcb, 0xa2, 0x1b, 0x89, 0x68, 0x1f, 0xca, 0xba, 0x0c, 0xc1, 0xa8, 0xed,
	0x51, 0x31, 0x20, 0x5d, 0x4d, 0xc3, 0x9b, 0x14, 0x62, 0x41, 0xf9, 0x35, 0x22, 0x37, 0xf4, 0x27,
	0x98, 0x37, 0x67, 0xa7, 0xd5, 0x19, 0x60, 0x2e, 0xed, 0x05, 0x1d, 0x26, 0x59, 0x8e, 0x7d, 0x0d,
	0x70, 0xa7, 0x14, 0x39, 0x62, 0x26, 0xc7, 0x83, 0x94, 0x5b, 0x32, 0xce, 0xbb, 0xca, 0x17, 0xfd,
	0x01, 0xe6, 0x07, 0xc4, 0xf3, 0x5b, 0x98, 0x77, 0x06, 0x74, 0x4c, 0xec, 0xb2, 0x8e, 0x65, 0x27,
	0x62, 0x9d, 0xf5, 0xcf, 0xe3, 0xee, 0x0a, 0xbf, 0x6d, 0xe0, 0x68, 0x1f, 0x16, 0x7d, 0x3c, 0xa4,
	0x3d, 0x22, 0xa4, 0x98, 0xc6, 0xa8, 0x7c, 0x32, 0x46, 0x75, 0xea, 0x14, 0x05, 0x3a, 0x05, 0x44,
	0x87, 0x42, 0x62, 0xcf, 0x33, 0xdc, 0x12, 0x92, 0x04, 0xc2, 0xae, 0xea, 0x48, 0xf7, 0x13, 0x91,
	0x0e, 0x63, 0xb0, 0xa6, 0x42, 0x1d, 0xa4, 0xdc, 0x45, 0x3a, 0xab, 0x44, 0xab, 0x50, 0x1a, 0x63,
	0x6f, 0x44, 0x44, 0x6b, 0x82, 0x7d, 0xcf, 0xbe, 0xaf, 0xf7, 0x02, 0x8c, 0xea, 0x1d, 0xf6, 0x3d,
	0xd4, 0x86, 0x0a, 0x27, 0x7f, 0x1f, 0x51, 0x4e, 0xba, 0x2d, 0x0f, 0xb7, 0x89, 0x27, 0xec, 0x55,
	0xcd, 0x81, 0x97, 0x37, 0xe2, 0x55, 0xcd, 0x0d, 0x9d, 0x8f, 0xb4, 0xef, 0xde, 0x50, 0xf2, 0x89,
	0x5b, 0xe6, 0x09, 0x25, 0x7a, 0x02, 0x73, 0x3d, 0x0f, 0x8f, 0x19, 0x17, 0xf6, 0xba, 0x8e, 0xbd,
	0x94, 0x88, 0xfd, 0x5a, 0xdb, 0xdc, 0x08, 0x83, 0x9e, 0x03, 0x04, 0x98, 0x63, 0x9f, 0x48, 0xc2,
	0x85, 0xfd, 0x48, 0x7b, 0xdc, 0x4e, 0x78, 0x34, 0x22, 0xb3, 0x1b, 0x43, 0xae, 0x6c, 0xc3, 0xd2,
	0x15, 0xd9, 0xa0, 0x2a, 0x64, 0xde, 0x93, 0x49, 0x48, 0x43, 0x35, 0x44, 0xcb, 0x90, 0xd3, 0x15,
	0x08, 0x1b, 0xa0, 0x11, 0x7e, 0x97, 0x7e, 0x61, 0xed, 0x2c, 0xc1, 0x62, 0xb2, 0xfe, 0x01, 0xe9,
	0x38, 0xdf, 0xa4, 0x61, 0xf1, 0x52, 0xb9, 0xd1, 0x4b, 0xc8, 0x99, 0xdd, 0x31, 0x47, 0xe6, 0x57,
	0x1f, 0xdf, 0x9d, 0x9a, 0xfa, 0x75, 0x8d, 0xc7, 0xca, 0xcf, 0x16, 0x64, 0x95, 0x3c, 0x6d, 0xc4,
	0xd9, 0x58, 0x23, 0x9e, 0xa5, 0xb5, 0xf5, 0x15, 0x69, 0x9d, 0xfe, 0x0a, 0xb4, 0xce, 0x7c, 0x3e,
	0xad, 0x77, 0xf2, 0x90, 0x55, 0x2b, 0x77, 0xbe, 0xb5, 0x20, 0x6f, 0x76, 0x7b, 0xba, 0x74, 0x2b,
	0xb6, 0xf4, 0x35, 0x28, 0xc5, 0xaf, 0x0d, 0xb3, 0x3b, 0x71, 0x15, 0xda, 0x83, 0xe5, 0xce, 0x48,
	0x48, 0xe6, 0xd3, 0x73, 0xb3, 0x41, 0x1e, 0x9e, 0x28, 0x92, 0x64, 0xf4, 0x1e, 0xa0, 0x44, 0x52,
	0x47, 0xca, 0xe4, 0x2e, 0x25, 0xf0, 0x5a, 0x27, 0xd0, 0x6b, 0xa8, 0x86, 0x14, 0x55, 0x77, 0x4c,
	0x4b, 0x10, 0x29, 0xec, 0xac, 0x0e, 0x71, 0x37, 0x11, 0xc2, 0xbd, 0x00, 0x35, 0x89, 0x74, 0x2b,
	0x3c, 0x21, 0x0b, 0xe7, 0x27, 0x0b, 0x8a, 0x53, 0x2e, 0x7e, 0xe1, 0x92, 0x36, 0x23, 0x32, 0x9a,
	0xc2, 0xde, 0xbd, 0x9a, 0xe8, 0x6f, 0x15, 0x24, 0x64, 0x2a, 0x7a, 0x06, 0x73, 0x5d, 0xd2, 0xc3,
	0x23, 0x4f, 0x6a, 0xe6, 0x7c, 0xc2, 0x29, 0xc2, 0xa2, 0x15, 0x28, 0x44, 0x07, 0x53, 0x5f, 0xc9,
	0x05, 0x77, 0x2a, 0xa3, 0x07, 0x30, 0xdf, 0xa5, 0x22, 0xf0, 0xf0, 0xa4, 0xa5, 0xd7, 0x90, 0x0f,
	0x13, 0x35, 0xba, 0x13, 0xec, 0x13, 0xe7, 0x7b, 0x0b, 0xca, 0xc9, 0xd0, 0xc8, 0x86, 0xbc, 0x90,
	0x9c, 0x0e, 0xfb, 0x66, 0xcd, 0x07, 0x29, 0x37, 0x94, 0xd1, 0x6d, 0xc8, 0xf5, 0x3c, 0x86, 0xa5,
	0x5e, 0x71, 0xfa, 0x20, 0xe5, 0x1a, 0x11, 0x2d, 0x43, 0xb6, 0xcd, 0x98, 0x79, 0x62, 0x14, 0x0e,
	0x52, 0xae, 0x96, 0x10, 0x82, 0x0c, 0x1d, 0x9a, 0xc5, 0x64, 0x0e, 0x52, 0xae, 0x12, 0xd0, 0x73,
	0xc8, 0xaa, 0x7e, 0xaf, 0x33, 0xbd, 0xc1, 0xed, 0xa0, 0x62, 0x29, 0x3c, 0xda, 0x82, 0xbc, 0x20,
	0x1d, 0x4e, 0xa4, 0x5e, 0xc3, 0x2c, 0x53, 0x9b, 0xda, 0xa4, 0xb3, 0xd7, 0xd9, 0x6a, 0x51, 0xf1,
	0x53, 0x3d, 0x8c, 0x9c, 0x23, 0x28, 0xc5, 0x00, 0x68, 0x03, 0x32, 0x9c, 0xf4, 0xc2, 0x13, 0x78,
	0xa7, 0xd6, 0x61, 0x9c, 0xc4, 0xa8, 0x21, 0xd8, 0x88, 0x77, 0x88, 0x4b, 0x7a, 0xae, 0x42, 0x45,
	0x6d, 0x26, 0x3d, 0x6d, 0x33, 0xce, 0xff, 0x2d, 0xc8, 0x69, 0xc2, 0xa1, 0x32, 0xa4, 0x69, 0x37,
	0xe4, 0x45, 0x9a, 0x5e, 0xae, 0x76, 0xfa, 0x52, 0xb5, 0xd5, 0x66, 0x31, 0x4d, 0x10, 0x1c, 0x16,
	0xcb, 0x9d, 0xca, 0x68, 0x0b, 0xe6, 0xcc, 0x38, 0x62, 0xad, 0x7d, 0x99, 0xf8, 0xa7, 0x1a, 0xe0,
	0x46, 0xc0, 0x99, 0xa6, 0x9a, 0xbb, 0x69, 0x53, 0x75, 0xfe, 0x6b, 0x41, 0x29, 0x16, 0xf0, 0x4b,
	0x96, 0x32, 0x73, 0x06, 0x32, 0x97, 0xcf, 0xc0, 0x53, 0x28, 0xbe, 0x0f, 0x8f, 0x29, 0x09, 0x29,
	0x9d, 0xcc, 0xed, 0x4d, 0x64, 0x75, 0x2f, 0x80, 0xea, 0x6e, 0xd3, 0xdd, 0xcd, 0xdc, 0x66, 0xe1,
	0x2b, 0x13, 0x94, 0x4a, 0x6f, 0x9f, 0x70, 0xfe, 0x63, 0x41, 0x71, 0xea, 0x89, 0xfe, 0x08, 0x79,
	0xd3, 0x1b, 0x3f, 0xb7, 0xa5, 0x86, 0x6e, 0xe8, 0xf7, 0x50, 0x92, 0xfd, 0xf3, 0xcf, 0x68, 0xa6,
	0x20, 0xfb, 0xe7, 0x51, 0x2f, 0x7d, 0x00, 0xf3, 0x6c, 0x4c, 0xb8, 0xaa, 0x53, 0x80, 0xe5, 0x20,
	0xaa, 0x42, 0xa8, 0x6b, 0x60, 0x39, 0xd8, 0x01, 0xf5, 0x04, 0x37, 0xce, 0x4e, 0x1f, 0x96, 0x4c,
	0xa3, 0xdc, 0x65, 0x7e, 0x80, 0x25, 0x6d, 0x53, 0x8f, 0xca, 0x09, 0x6a, 0x40, 0xb5, 0x13, 0x2a,
	0x3c, 0xd2, 0x0a, 0x30, 0xe5, 0xd1, 0xfd, 0x93, 0x5c, 0xcd, 0xee, 0x14, 0x64, 0xa2, 0x1c, 0x13,
	0x31, 0x68, 0x60, 0xca, 0xdd, 0xca, 0x85, 0xbb, 0x92, 0x85, 0x33, 0x06, 0xfb, 0x3a, 0x30, 0xda,
	0x80, 0xbc, 0xb9, 0x93, 0xc3, 0x8a, 0x5d, 0x79, 0x6d, 0x87, 0x10, 0xf4, 0x04, 0xb2, 0x3e, 0x11,
	0x83, 0xb0, 0x2c, 0x1f, 0x39, 0x2d, 0x1a, 0xe6, 0xbc, 0x83, 0x72, 0xb2, 0xbb, 0xa2, 0x7d, 0xa8,
	0x2a, 0x4b, 0x2b, 0xd6, 0x64, 0xc3, 0x79, 0x93, 0xcf, 0x51, 0x95, 0x5e, 0xcc, 0xd5, 0xad, 0xf8,
	0x49, 0x85, 0xf3, 0x4f, 0xa8, 0xcc, 0x60, 0xd0, 0x16, 0x14, 0x75, 0xec, 0xd8, 0x87, 0xd2, 0xad,
	0x4b, 0x41, 0xf5, 0x17, 0x52, 0xc1, 0x0f, 0x47, 0xe8, 0x45, 0xec, 0xa9, 0x9d, 0xbe, 0x22, 0x8f,
	0x6d, 0xcf, 0x63, 0xff, 0x20, 0xdd, 0xf0, 0x65, 0x24, 0x62, 0x2f, 0xec, 0x00, 0xec, 0xeb, 0xe8,
	0xa4, 0xda, 0x04, 0xe3, 0xfd, 0xe8, 0x35, 0xc2, 0x78, 0x5f, 0x5d, 0x1b, 0xea, 0x1b, 0x26, 0xfa,
	0x1a, 0x53, 0x63, 0x85, 0x52, 0x9d, 0xc7, 0x90, 0x44, 0xb7, 0x97, 0x7b, 0x50, 0xec, 0x52, 0x4e,
	0x3a, 0x2a, 0x58, 0xf8, 0x5e, 0xb8, 0x50, 0x38, 0xab, 0x50, 0x8a, 0x51, 0x4f, 0xb9, 0x8f, 0x38,
	0x8d, 0x26, 0x19, 0x71, 0xea, 0x34, 0xa1, 0x32, 0x93, 0xaf, 0x3a, 0x3e, 0x3e, 0x1d, 0xb6, 0xa2,
	0x67, 0xba, 0x99, 0x1e, 0x7c, 0x3a, 0x0c, 0x11, 0x1a, 0x80, 0x3f, 0x4c, 0x01, 0x99, 0x10, 0x80,
	0x3f, 0x84, 0x80, 0xc7, 0x4f, 0x13, 0x1f, 0xa3, 0xba, 0x68, 0x0b, 0x50, 0xdc, 0xfb, 0xeb, 0xd9,
	0xde, 0x49, 0xf3, 0xf0, 0xf4, 0xa4, 0x9a, 0x42, 0x05, 0xc8, 0xbe, 0xda, 0x3b, 0x3e, 0xad, 0x5a,
	0x6a, 0x74, 0xbc, 0xd7, 0x3c, 0xa8, 0xa6, 0x1f, 0x3f, 0x85, 0x42, 0x54, 0x6d, 0x54, 0x84, 0xdc,
	0x61, 0xf3, 0xec, 0xf0, 0xb4, 0x9a, 0x42, 0x25, 0x98, 0x3b, 0x3a, 0x3c, 0x79, 0xb3, 0xe7, 0xbe,
	0xaa, 0x5a, 0xa8, 0x0a, 0xf3, 0xdb, 0x7f, 0x69, 0xb6, 0xb6, 0x1b, 0x8d, 0x96, 0xf1, 0xda, 0x29,
	0xfc, 0xfb, 0x87, 0xfb, 0xd6, 0xdf, 0xd2, 0xe3, 0xcd, 0x76, 0x5e, 0x5f, 0x01, 0xbf, 0xfd, 0x25,
	0x00, 0x00, 0xff, 0xff, 0xbd, 0x82, 0xf9, 0x5c, 0x95, 0x0f, 0x00, 0x00,
}

func (this *ApplicationSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApplicationSpec)
	if !ok {
		that2, ok := that.(ApplicationSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.LogoUrl != that1.LogoUrl {
		return false
	}
	if this.ShortDescription != that1.ShortDescription {
		return false
	}
	if this.LongDescription != that1.LongDescription {
		return false
	}
	if this.DocumentationUrl != that1.DocumentationUrl {
		return false
	}
	if this.RepositoryUrl != that1.RepositoryUrl {
		return false
	}
	if this.ApplicationCreator != that1.ApplicationCreator {
		return false
	}
	if this.ApplicationProvider != that1.ApplicationProvider {
		return false
	}
	if this.ApplicationMaintainer != that1.ApplicationMaintainer {
		return false
	}
	if that1.DateCreated == nil {
		if this.DateCreated != nil {
			return false
		}
	} else if !this.DateCreated.Equal(*that1.DateCreated) {
		return false
	}
	if len(this.Versions) != len(that1.Versions) {
		return false
	}
	for i := range this.Versions {
		if !this.Versions[i].Equal(that1.Versions[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ApplicationSpecs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApplicationSpecs)
	if !ok {
		that2, ok := that.(ApplicationSpecs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Specs) != len(that1.Specs) {
		return false
	}
	for i := range this.Specs {
		if !this.Specs[i].Equal(that1.Specs[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *VersionedApplicationSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VersionedApplicationSpec)
	if !ok {
		that2, ok := that.(VersionedApplicationSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if that1.DatePublished == nil {
		if this.DatePublished != nil {
			return false
		}
	} else if !this.DatePublished.Equal(*that1.DatePublished) {
		return false
	}
	if that1.InstallationSpec == nil {
		if this.InstallationSpec != nil {
			return false
		}
	} else if this.InstallationSpec == nil {
		return false
	} else if !this.InstallationSpec.Equal(that1.InstallationSpec) {
		return false
	}
	if this.ValuesYaml != that1.ValuesYaml {
		return false
	}
	if len(this.RequiredLabels) != len(that1.RequiredLabels) {
		return false
	}
	for i := range this.RequiredLabels {
		if this.RequiredLabels[i] != that1.RequiredLabels[i] {
			return false
		}
	}
	if len(this.Flavors) != len(that1.Flavors) {
		return false
	}
	for i := range this.Flavors {
		if !this.Flavors[i].Equal(that1.Flavors[i]) {
			return false
		}
	}
	if len(this.Parameters) != len(that1.Parameters) {
		return false
	}
	for i := range this.Parameters {
		if !this.Parameters[i].Equal(that1.Parameters[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *VersionedApplicationSpec_GithubChart) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VersionedApplicationSpec_GithubChart)
	if !ok {
		that2, ok := that.(VersionedApplicationSpec_GithubChart)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GithubChart.Equal(that1.GithubChart) {
		return false
	}
	return true
}
func (this *VersionedApplicationSpec_HelmArchive) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VersionedApplicationSpec_HelmArchive)
	if !ok {
		that2, ok := that.(VersionedApplicationSpec_HelmArchive)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HelmArchive.Equal(that1.HelmArchive) {
		return false
	}
	return true
}
func (this *VersionedApplicationSpec_ManifestsArchive) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VersionedApplicationSpec_ManifestsArchive)
	if !ok {
		that2, ok := that.(VersionedApplicationSpec_ManifestsArchive)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ManifestsArchive.Equal(that1.ManifestsArchive) {
		return false
	}
	return true
}
func (this *VersionedApplicationSpec_InstallationSteps) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VersionedApplicationSpec_InstallationSteps)
	if !ok {
		that2, ok := that.(VersionedApplicationSpec_InstallationSteps)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InstallationSteps.Equal(that1.InstallationSteps) {
		return false
	}
	return true
}
func (this *InstallationSteps) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InstallationSteps)
	if !ok {
		that2, ok := that.(InstallationSteps)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Steps) != len(that1.Steps) {
		return false
	}
	for i := range this.Steps {
		if !this.Steps[i].Equal(that1.Steps[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *InstallationSteps_Step) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InstallationSteps_Step)
	if !ok {
		that2, ok := that.(InstallationSteps_Step)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.Step == nil {
		if this.Step != nil {
			return false
		}
	} else if this.Step == nil {
		return false
	} else if !this.Step.Equal(that1.Step) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *InstallationSteps_Step_GithubChart) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InstallationSteps_Step_GithubChart)
	if !ok {
		that2, ok := that.(InstallationSteps_Step_GithubChart)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GithubChart.Equal(that1.GithubChart) {
		return false
	}
	return true
}
func (this *InstallationSteps_Step_HelmArchive) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InstallationSteps_Step_HelmArchive)
	if !ok {
		that2, ok := that.(InstallationSteps_Step_HelmArchive)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HelmArchive.Equal(that1.HelmArchive) {
		return false
	}
	return true
}
func (this *InstallationSteps_Step_ManifestsArchive) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InstallationSteps_Step_ManifestsArchive)
	if !ok {
		that2, ok := that.(InstallationSteps_Step_ManifestsArchive)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ManifestsArchive.Equal(that1.ManifestsArchive) {
		return false
	}
	return true
}
func (this *Flavor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Flavor)
	if !ok {
		that2, ok := that.(Flavor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.CustomizationLayers) != len(that1.CustomizationLayers) {
		return false
	}
	for i := range this.CustomizationLayers {
		if !this.CustomizationLayers[i].Equal(that1.CustomizationLayers[i]) {
			return false
		}
	}
	if len(this.RequirementSets) != len(that1.RequirementSets) {
		return false
	}
	for i := range this.RequirementSets {
		if !this.RequirementSets[i].Equal(that1.RequirementSets[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Parameter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Parameter)
	if !ok {
		that2, ok := that.(Parameter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !this.Value.Equal(that1.Value) {
		return false
	}
	if !this.Default.Equal(that1.Default) {
		return false
	}
	if this.Required != that1.Required {
		return false
	}
	if this.DisplayName != that1.DisplayName {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ParameterValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ParameterValue)
	if !ok {
		that2, ok := that.(ParameterValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ParameterValue_String_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ParameterValue_String_)
	if !ok {
		that2, ok := that.(ParameterValue_String_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.String_ != that1.String_ {
		return false
	}
	return true
}
func (this *ParameterValue_Float) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ParameterValue_Float)
	if !ok {
		that2, ok := that.(ParameterValue_Float)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Float != that1.Float {
		return false
	}
	return true
}
func (this *ParameterValue_Bool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ParameterValue_Bool)
	if !ok {
		that2, ok := that.(ParameterValue_Bool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Bool != that1.Bool {
		return false
	}
	return true
}
func (this *ParameterValue_Int) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ParameterValue_Int)
	if !ok {
		that2, ok := that.(ParameterValue_Int)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Int != that1.Int {
		return false
	}
	return true
}
func (this *ParameterValue_Date) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ParameterValue_Date)
	if !ok {
		that2, ok := that.(ParameterValue_Date)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Date == nil {
		if this.Date != nil {
			return false
		}
	} else if !this.Date.Equal(*that1.Date) {
		return false
	}
	return true
}
func (this *ParameterValue_Secret) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ParameterValue_Secret)
	if !ok {
		that2, ok := that.(ParameterValue_Secret)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Secret.Equal(that1.Secret) {
		return false
	}
	return true
}
func (this *SecretValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecretValue)
	if !ok {
		that2, ok := that.(SecretValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ref.Equal(that1.Ref) {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Layer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Layer)
	if !ok {
		that2, ok := that.(Layer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.DisplayName != that1.DisplayName {
		return false
	}
	if this.Optional != that1.Optional {
		return false
	}
	if len(this.Options) != len(that1.Options) {
		return false
	}
	for i := range this.Options {
		if !this.Options[i].Equal(that1.Options[i]) {
			return false
		}
	}
	if len(this.Parameters) != len(that1.Parameters) {
		return false
	}
	for i := range this.Parameters {
		if !this.Parameters[i].Equal(that1.Parameters[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *LayerOption) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LayerOption)
	if !ok {
		that2, ok := that.(LayerOption)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.DisplayName != that1.DisplayName {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !this.Kustomize.Equal(that1.Kustomize) {
		return false
	}
	if this.HelmValues != that1.HelmValues {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Kustomize) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Kustomize)
	if !ok {
		that2, ok := that.(Kustomize)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Location == nil {
		if this.Location != nil {
			return false
		}
	} else if this.Location == nil {
		return false
	} else if !this.Location.Equal(that1.Location) {
		return false
	}
	if this.OverlayPath != that1.OverlayPath {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Kustomize_Github) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Kustomize_Github)
	if !ok {
		that2, ok := that.(Kustomize_Github)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Github.Equal(that1.Github) {
		return false
	}
	return true
}
func (this *Kustomize_TgzArchive) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Kustomize_TgzArchive)
	if !ok {
		that2, ok := that.(Kustomize_TgzArchive)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TgzArchive.Equal(that1.TgzArchive) {
		return false
	}
	return true
}
func (this *FlavorCompatibility) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlavorCompatibility)
	if !ok {
		that2, ok := that.(FlavorCompatibility)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.CompatiblePairs) != len(that1.CompatiblePairs) {
		return false
	}
	for i := range this.CompatiblePairs {
		if !this.CompatiblePairs[i].Equal(that1.CompatiblePairs[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *CompatibleFlavorMeshPair) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CompatibleFlavorMeshPair)
	if !ok {
		that2, ok := that.(CompatibleFlavorMeshPair)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Flavor.Equal(that1.Flavor) {
		return false
	}
	if !this.Mesh.Equal(that1.Mesh) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RequirementSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequirementSet)
	if !ok {
		that2, ok := that.(RequirementSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MeshRequirement.Equal(that1.MeshRequirement) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *MeshRequirement) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MeshRequirement)
	if !ok {
		that2, ok := that.(MeshRequirement)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MeshType != that1.MeshType {
		return false
	}
	if !this.Versions.Equal(that1.Versions) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *GithubRepositoryLocation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GithubRepositoryLocation)
	if !ok {
		that2, ok := that.(GithubRepositoryLocation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Org != that1.Org {
		return false
	}
	if this.Repo != that1.Repo {
		return false
	}
	if this.Ref != that1.Ref {
		return false
	}
	if this.Directory != that1.Directory {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TgzLocation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TgzLocation)
	if !ok {
		that2, ok := that.(TgzLocation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Uri != that1.Uri {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *AllowedVersions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllowedVersions)
	if !ok {
		that2, ok := that.(AllowedVersions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MinVersion != that1.MinVersion {
		return false
	}
	if this.MaxVersion != that1.MaxVersion {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
